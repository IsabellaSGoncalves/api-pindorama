Todo esse crud Back e Front está funcionando, eu preciso dos respectivos códigos mas para o Crud de eventos.
nomes: eventos_controller.rb
evento.rb

hook: useGetEventosAdmin.js 
Página: CriarEvento.jsx 
O código precisa considerar alguns desses nomes abaixo para se relacionar ao banco. 

artigos_controller.rb
class ArtigosController < ApplicationController
  before_action :set_artigo, only: %i[ show update destroy ]

  # GET /artigos
  def index
    if params[:autor_id].present?
      @artigos = Artigo.where(autor_id: params[:autor_id])
    else
      @artigos = Artigo.all
    end
    render json: @artigos
  end

  # GET /artigos/1
  def show
    render json: @artigo
  end

  # POST /artigos
  def create
    uploaded_image = params[:imagem]

    image_url = nil
    if uploaded_image.present? # Se uma imagem foi enviada
      # Dá upload na imagem e armazena os dados em result
      result = Cloudinary::Uploader.upload( uploaded_image, folder: "artigos", public_id: SecureRandom.uuid)
      # Pega a URL da imagem a partir do resultado do upload
      image_url = result["secure_url"]
    end
    # Cria um novo artigo com os parametros
    @artigo = Artigo.new(artigo_params.merge(url_imagem: image_url))

    if @artigo.save
      render json: @artigo, status: :created, location: @artigo
    else
      render json: @artigo.errors, status: :unprocessable_entity
    end
  end

  # PATCH/PUT /artigos/1
  def update
    uploaded_image = params[:imagem]

    if uploaded_image.present?
      # Se já existe imagem, remove a antiga
      if @artigo.url_imagem.present?
        public_id = extract_public_id(@artigo.url_imagem)
        Cloudinary::Uploader.destroy(public_id)
      end

      # Faz upload da nova imagem
      result = Cloudinary::Uploader.upload( uploaded_image, folder: "artigos", public_id: SecureRandom.uuid)
      image_url = result["secure_url"]

      # Atualiza com a nova URL
      if @artigo.update(artigo_params.merge(url_imagem: image_url))
        render json: @artigo
      else
        render json: @artigo.errors, status: :unprocessable_entity
      end
    else
      # Atualiza só os outros campos
      if @artigo.update(artigo_params)
        render json: @artigo
      else
        render json: @artigo.errors, status: :unprocessable_entity
      end
    end
  end

  # DELETE /artigos/1
  def destroy
    if @artigo.url_imagem.present?
      # extrai o public_id da url(Opção dois onde nao armazenamos o public_id da imagem no proprio artigo)
      public_id = extract_public_id(@artigo.url_imagem)
      Cloudinary::Uploader.destroy(public_id)
    end

    @artigo.destroy!
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_artigo
      @artigo = Artigo.find(params.expect(:id))
    end

    # Only allow a list of trusted parameters through.
    def artigo_params
      params.require(:artigo).permit(:titulo, :conteudo, :local, :data, :autor_id, :status, tags: [])
    end

    # Método para extrair public_id de qualquer URL do Cloudinary
    def extract_public_id(url)
      # Pega tudo depois de "upload/" e remove versão (ex: v123456)
      parts = url.split("/upload/").last.split("/")
      parts.shift if parts.first.start_with?("v") # remove o "v12345"
      public_id_with_ext = parts.join("/")        # artigos/uuid.png
      public_id = public_id_with_ext.sub(File.extname(public_id_with_ext), "") # remove extensão
      public_id
    end
end

Models artigos.rb
# belongs_to = pertence_a
# optional: true permite que isso seja falso

class Artigo < ApplicationRecord
  belongs_to :autor, optional: true
end

hooks> useGetArtigosAdmin.js
import { useState, useEffect } from 'react';

const API_BASE_URL = import.meta.env.VITE_API_URL;
const API_URL = `${API_BASE_URL}/artigos`;

export const useGetArtigosAdmin = (autorId) => {
    const [artigos, setArtigos] = useState([]);
    const [loading, setLoading] = useState(false); 
    const [error, setError] = useState(null);

    useEffect(() => {
        if (!autorId) {
            setLoading(false);
            setArtigos([]);
            return;
        }

        const fetchartigos = async () => {
            setLoading(true);
            setError(null);

            try {
                const url = `${API_URL}?autor_id=${autorId}`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Erro ao buscar os artigos do autor');
                }
                const data = await response.json();
                setArtigos(data);
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };

        fetchartigos();

    }, [autorId]); 

    return { artigos, loading, error };
};

página CriarArtigo.jsx 
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import useTituloDocumento from '../../../hooks/useTituloDocumento.js';
import EditorDeTexto from '../../../components/EditorDeTexto/EditorDeTexto.jsx';
import styles from './CriarArtigo.module.scss';
import Logo from '../../../assets/images/pindorama_logo5.png';
import { FaTags, FaMapMarkerAlt } from 'react-icons/fa';
import PopupConfirmar from '../../../components/Popups/PopupConfirmar/PopupConfirmar.jsx';
import PopupSucesso from '../../../components/Popups/PopupSucesso/PopupSucesso.jsx';
import PopupTagArtigo from "../../../components/Popups/PopupAdicionarTag/PopupAdicionarTag.jsx";
import HeaderAdmin from '../../../components/HeaderAdmin/HeaderAdmin.jsx';
import PopupLocal from '../../../components/Popups/PopupLocal/PopupLocal.jsx';
import PopupErro from '../../../components/Popups/PopupErro/PopupErro.jsx';
import { tratamentoErro as tratarErro } from '../../../Helpers/tratamentoErro.js';
import { useArtigos } from '../../../hooks/artigos/useArtigos.js';
import { useParams } from 'react-router-dom';

// --- Constantes ---
const nomeAutora = "Kelly Cristina Marques";
const mockLocais = [
    { id: 1, cidade: 'Recife', estado: 'PE' },
    { id: 2, cidade: 'Salvador', estado: 'BA' },
    { id: 3, cidade: 'São Paulo', estado: 'SP' },
    { id: 4, cidade: 'Rio de Janeiro', estado: 'RJ' },
    { id: 5, cidade: 'Belo Horizonte', estado: 'MG' },
    { id: 6, cidade: 'Vitória', estado: 'ES' },
    { id: 7, cidade: 'Palmas', estado: 'TO' },
];

function PaginaCriarArtigo() {
    useTituloDocumento("Criar Artigo | Pindorama");
    const { id } = useParams();
    const navigate = useNavigate();

    // --- Hook personalizado para lidar com artigos ---
    const { atualizarArtigo, buscarArtigo, criarArtigo, loading, erro } = useArtigos();

    // --- Estados do Formulário ---
    const [titulo, setTitulo] = useState('');
    const [conteudo, setConteudo] = useState('');
    const [imagemCapa, setImagemCapa] = useState(null);
    const [previewCapa, setPreviewCapa] = useState('');
    const [localSelecionado, setLocalSelecionado] = useState(null);
    const [tagsSelecionadas, setTagsSelecionadas] = useState([]);
    const [erroFormulario, setErroFormulario] = useState(null);

    // --- Estados de Controle dos Popups ---
    const [localModalAberto, setLocalModalAberto] = useState(false);
    const [popupTagAberto, setPopupTagAberto] = useState(false);
    const [popupErroAberto, setPopupErroAberto] = useState(false);
    const [mostrarConfirmacaoExcluir, setMostrarConfirmacaoExcluir] = useState(false);
    const [mostrarConfirmacaoEnvio, setMostrarConfirmacaoEnvio] = useState(false);
    const [mostrarSucesso, setMostrarSucesso] = useState(false);
    const [popupSucessoMensagem, setPopupSucessoMensagem] = useState('');
    const [acaoAposSucesso, setAcaoAposSucesso] = useState(null);

    // Novo estado para controlar o status
    const [statusEnvio, setStatusEnvio] = useState("publicado");

    // --- Funções de Handler ---
    const handleEditorChange = (content) => { setConteudo(content); };
    const handleImagemChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            setImagemCapa(file);
            setPreviewCapa(URL.createObjectURL(file));
        }
    };
    const handleSelecionarLocal = (local) => {
        setLocalSelecionado(local);
        setLocalModalAberto(false);
    };
    const handleConfirmarTags = (tags) => {
        setTagsSelecionadas(tags);
        setPopupTagAberto(false);
    };

    // --- Lógica de Exclusão ---
    const handleExcluirClick = () => {
        const formularioEstaVazio = !titulo.trim() && (!conteudo || conteudo === '<p><br data-mce-bogus="1"></p>') && !imagemCapa && tagsSelecionadas.length === 0 && !localSelecionado;
        if (formularioEstaVazio) {
            setPopupSucessoMensagem('Não há informações para excluir.');
            setAcaoAposSucesso('permanecer');
            setMostrarSucesso(true);
        } else {
            setMostrarConfirmacaoExcluir(true);
        }
    };
    const handleConfirmarExclusao = () => {
        setTitulo('');
        setConteudo('');
        setImagemCapa(null);
        setPreviewCapa('');
        setLocalSelecionado(null);
        setTagsSelecionadas([]);
        setMostrarConfirmacaoExcluir(false);
        setPopupSucessoMensagem('Informações excluídas com sucesso!');
        setAcaoAposSucesso('permanecer');
        setMostrarSucesso(true);
    };
    const handleCancelarExclusao = () => { setMostrarConfirmacaoExcluir(false); };

    // --- Lógica de Envio ---
    const handleSubmit = (event, status = "publicado") => {
        event.preventDefault();
        setErroFormulario(null);

        setStatusEnvio(status);

        const mostrarErro = (mensagem) => {
            const erroTratado = tratarErro(mensagem);
            setErroFormulario(erroTratado);
        };

        const conteudoVazio = !conteudo || conteudo === '<p><br data-mce-bogus="1"></p>';
        const formularioVazio =
            !titulo.trim() &&
            conteudoVazio &&
            !imagemCapa &&
            tagsSelecionadas.length === 0 &&
            !localSelecionado;

        if (status === "publicado") {
            // Publicação: todos os campos obrigatórios
            if (!titulo.trim()) return mostrarErro('Por favor, adicione um título.');
            if (conteudoVazio) return mostrarErro('O conteúdo do artigo não pode estar vazio.');
            if (!imagemCapa && !previewCapa) return mostrarErro('Por favor, adicione uma imagem de capa.');
            if (tagsSelecionadas.length === 0) return mostrarErro('Selecione pelo menos uma tag.');
            if (!localSelecionado) return mostrarErro('Selecione um local.');
        } else if (status === "rascunho") {
            // Rascunho: pelo menos um campo deve estar preenchido
            if (formularioVazio) return mostrarErro('Preencha pelo menos um campo para salvar como rascunho.');
            
            if (!titulo.trim()) setTitulo("Rascunho sem título");
            if (conteudoVazio) setConteudo("<p>Conteúdo do rascunho</p>");
          }

        // Se passou nas validações
        setMostrarConfirmacaoEnvio(true);
        setAcaoAposSucesso("redirecionar");
    };

      const executarEnvio = async (status = "publicado") => {
          try {
              const artigoParaEnviar = {
                  titulo,
                  conteudo,
                  autor_id: 7,
                  status: statusEnvio, // "rascunho" ou "publicado"
                  local: localSelecionado ? `${localSelecionado.cidade} - ${localSelecionado.estado}` : null,
                  tags: tagsSelecionadas,
              };

              if (id) {
                await atualizarArtigo(id, artigoParaEnviar, imagemCapa || null ); // modo edição
              } else {
                await criarArtigo(artigoParaEnviar, imagemCapa); // modo criação
              }

              setMostrarConfirmacaoEnvio(false);
              setPopupSucessoMensagem(
                status === "rascunho"
                  ? "Artigo salvo como rascunho!"
                  : id
                  ? "Artigo atualizado com sucesso!"
                  : "Artigo enviado com sucesso!"
              );
              setMostrarSucesso(true);
          } catch (e) {
              console.error(e);
              setErroFormulario({ mensagem: e.message, tipo: "erro" });
          }
      };

    const handleCancelarEnvio = () => { setMostrarConfirmacaoEnvio(false); };

    // --- Lógica do Popup de Sucesso ---
    const handleFecharPopupSucesso = () => {
        setMostrarSucesso(false);
        if (acaoAposSucesso === 'redirecionar') {
            navigate('/adm/visualizar-artigos');
        }
        setAcaoAposSucesso(null);
    };

    useEffect(() => {
      if (id) {
        async function carregar() {
          try {
            const artigo = await buscarArtigo(id);
            setTitulo(artigo.titulo);
            setConteudo(artigo.conteudo);
            setTagsSelecionadas(artigo.tags || []);
            if (artigo.local && artigo.local.includes(" - ")) {
              const [cidade, estado] = artigo.local.split(" - ");
              setLocalSelecionado({ cidade, estado });
            } else {
              setLocalSelecionado(null);
            }
            setPreviewCapa(artigo.url_imagem || "");
            // imagemCapa não precisa ser setado agora, só quando trocar
          } catch (e) {
            console.error("Erro ao carregar artigo", e);
          }
        }
        carregar();
      }
    }, [id]);

    return (
        <main className={styles.base}>
            <header className={styles.cabecalho}>
                <Link to="/adm/inicio" className={styles.logo}>
                    <img className={styles.logoImage} src={Logo} alt="Logo Pindorama - Voltar para a página inicial" />
                </Link>
                <h1 className={styles.titulo}>Artigos</h1>
                <HeaderAdmin />
            </header>

            <form className={styles.formGrid}>
                <div className={styles.campoTitulo}>
                    <input
                        type="text"
                        id="tituloArtigo"
                        name="titulo"
                        placeholder="Adicione o título aqui"
                        value={titulo}
                        onChange={(e) => setTitulo(e.target.value)}
                    />
                </div>
                <div className={styles.campoEditor}>
                    <EditorDeTexto
                        value={conteudo}
                        onContentChange={handleEditorChange}
                    />
                </div>
                <div className={styles.campoDropdowns}>
                    <button
                        type='button'
                        className={styles.selectWrapper}
                        onClick={() => setPopupTagAberto(true)}
                    >
                        <FaTags /> Tags
                    </button>
                    <button
                        type='button'
                        className={styles.selectWrapper}
                        onClick={() => setLocalModalAberto(true)}
                    >
                        <FaMapMarkerAlt /> {localSelecionado ? `${localSelecionado.cidade} - ${localSelecionado.estado}` : 'Local'}
                    </button>
                </div>
                <div className={styles.campoMidia}>
                    <label htmlFor="upload-capa">
                        {previewCapa ? <img src={previewCapa} alt="Prévia da capa" className={styles.previewImagem} /> : <div className={styles.placeholderMidia}>Adicione sua mídia aqui</div>}
                    </label>
                    <input
                        id="upload-capa"
                        type="file"
                        accept="image/png, image/jpeg, image/webp"
                        onChange={handleImagemChange}
                        style={{ display: 'none' }}
                    />
                </div>
                <div className={styles.campoBotoes}>
                    <button
                        type="button"
                        className={styles.botaoExcluir}
                        onClick={handleExcluirClick}
                    >
                        Limpar
                    </button>
                    <div className={styles.botoesDireita}>
                      <button
                          type="button"
                          className={styles.botaoRascunho}
                          onClick={(e) => handleSubmit(e, "rascunho")}
                      >
                          Salvar como rascunho
                      </button>

                      <button
                          type="button"
                          className={styles.botaoEnviar}
                          onClick={(e) => handleSubmit(e, "publicado")}
                      >
                          Enviar
                      </button>
                    </div>
                </div>
            </form>

            <PopupConfirmar
                aberto={mostrarConfirmacaoExcluir}
                mensagem="Tem certeza que deseja limpar todos os campos?"
                onCancelar={handleCancelarExclusao}
                onConfirmar={handleConfirmarExclusao}
            />

            <PopupConfirmar
              aberto={mostrarConfirmacaoEnvio}
              mensagem={
                statusEnvio === "rascunho"
                  ? "Tudo pronto para enviar como rascunho?"
                  : "Tudo pronto para publicar?"
              }
              onCancelar={handleCancelarEnvio}
              onConfirmar={() => executarEnvio(statusEnvio)}
            />

            <PopupSucesso
                aberto={mostrarSucesso}
                mensagem={popupSucessoMensagem}
                textoBotao="Ok"
                onBotaoClick={handleFecharPopupSucesso}
            />

            <PopupTagArtigo
                aberto={popupTagAberto}
                tagsIniciais={tagsSelecionadas}
                onCancelar={() => setPopupTagAberto(false)}
                onConfirmar={handleConfirmarTags}
            />

            <PopupLocal
                aberto={localModalAberto}
                locais={mockLocais}
                onClose={() => setLocalModalAberto(false)}
                onSelect={handleSelecionarLocal}
            />

            {erroFormulario && (
                <PopupErro
                    aberto={!!erroFormulario}
                    mensagem={erroFormulario.mensagem}
                    tipo={erroFormulario.tipo}
                    onClose={() => setErroFormulario(null)}
                />
            )}
        </main>
    );
};

export default PaginaCriarArtigo;

